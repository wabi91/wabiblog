---
title: "도커, 컨테이너"
date: 2020-12-27 20:12:29
category: docker
thumbnail: { thumbnailSrc }
draft: false
---

> 오픈 소스로 공개되는 프레임워크를 사용한 개발은 단기간 고품질의 애플리케이션 개발이 가능하지만, 빈번한 버전 업, 버그 수정, 보안 패치 등으로 애플리케이션 소프트웨어의 안정성을 유지하기가 어렵다. 도커는 컨테이너를 통해서 오픈소스를 사용한 개발 생산성 향상 + 애플리케이션 안정성 두 가지를 확보할 수 있다.

## 컨테이너 사용이유

- 인프라의 사용률 향상
  - 하나의 물리 서버나 가상 서버 위에서 여러 개의 컨테이너를 돌릴 수 있다.
  - CPU와 메모리 사용률을 높여 하드웨어를 효율적으로 이용할 수 있다.
- 빠른 기동 시간
  - 컨테이너의 기동 시간은 가상 서버나 물리 서버의 기동 시간보다 훨씬 빠르다. (OS 기동시간, 가상서버는 분단위/컨테이너는 초단위)
  - 운영 체제, 애플리케이션, 미들웨어 등 다양한 이미지를 쉽게 얻을 수 있다.
  - 설치 작업이나 설정 작업이 줄어든다.
  - 네트워크, 볼륨(외부 저장)을 소프트웨어 정의 오브젝트로 작성할 수 있다.
- 불변 실행 환경
  - 애플리케이션 실행에 필요한 소프트웨어를 모두 포함하여 컨테이너를 작성할 수 있다.
  - 컨테이너를 조합하여 시스템을 구성함으로써 특정 서버 환경에 대한 종속성을 배제할 수 있다.
  - 개발 환경과 운영 환경의 차이를 줄일 수 있다.

## 도커 구성 요소

### 도커 데몬

도커 커맨드, 클라이언트 명령을 받아들여서 오브젝트인 도커 이미지, 컨테이너, 볼륨, 네트워크 등을 관리한다. 네트워크 너머에 있는 원격 클라이언트로부터 요청을 받는 것도 가능하다.

### 도커 클라이언트

도커 커맨드는 컨테이너를 조작하는 커맨드 라인 유저 인터페이스로 `CUI` 도커 데몬의 클라이언트 이다. 도커 커맨드는 도커 API를 사용하여 도커 데몬에 요청을 보내고 도커 커맨드를 통해 자주 사용하는 서브 커맨드는 다음과 같다.

- docker build: 베이스 이미지에 기능을 추가/새로운 이미지를 생성
- docker pull: 레지스트리에서 이미지를 로컬에 다운로드
- docker run: 이미지를 바탕으로 컨테이너를 실행
- docker ps / docker container ls: 실행 중인 도커 컨테이너 목록을 얻는다.

### 이미지

읽기 전용인 컨테이너 템플릿으로 컨테이너를 기동하기 위한 실행 파일과 설정 파일의 묶을으로 볼 수 있다. 컨테이너를 실행하면 이미지에 담긴 미들웨어나 애플리케이션이 설정에 따라 기동한다. 도커 허브에는 데이터베이스, 웹 서버, 애플리케이션 등 다양한 이미지가 등록되어 있다.<br/>
호스트의 로컬에 이미지가 존재하지 않는 경우에는 자동으로 원격 레지스트리에서 다운받아 실행된다. (이미지 다운만 원할 경우, `docker pull`)

> 대부분의 이미지는 다른 이미지에 기반하여 만들어진다. > 이미지를 만들 때는 기반 이미지와 설치 스크립트 등을 Dockerfile에 기재하여 빌드한다.

### 컨테이너

컨테이너는 하나의 프로세스로 리눅스의 네임스페이스나 컨트롤 그룹을 통해 다른 프로세스들과 완전히 분리되어 실행되는 프로세스이다. (컨테이너는 정지된 상태로도 관리가 가능하므로 '실행 가능한 이미지의 인스턴스' 로 보면 된다.)

- `docker run` 명령어로 이미지는 컨테이너로 변화되어 하나의 인스턴스가 되고 IP주소를 가지는 하나의 독립된 서버로 동작한다.
- `docker stop / kill` 명령어로 컨테이너를 정상 종료, 강제 종료를 할 수 있다.
- `docker rm` 명령어로 정지 상태인 컨테이너를 지울 수 있다. (반대로 `docker start` 명령어로 재가동 한다. * 재가동시, 정지전 할당된 IP주소가 유지되지 않는다.)

### 도커 레지스트리

컨테이너의 이미지가 보관되는 곳으로 기본적인 path는 도커 허브에 있는 이미지를 찾도록 설정되어있다.

- 레지스트리: 리포지터리를 여러개 가지는 보관 서비스
- 리포지터리: 하나의 이미지에 대해 태그를 사용해서 다양한 출시 버전을 함께 보관하는 곳

## 쿠버네티스에서 컨테이너가 동작할 때까지의 흐름

1. docker build 로 이미지를 빌드
2. docker push로 이미지를 레지스트리에 등록
3. kubectl 커맨드로 매니페스트에 기재한 오브젝트들의 생성을 요청
4. 매니페스트에 기재된 리포지터리로부터 컨테이너의 이미지를 다운로드
5. 컨테이너를 파드 위에서 기동

# 정리

- 컨테이너를 사용하면 오픈 소스를 효율적으로 사용하여 애플리케이션을 개발할 수 있고 안정적인 배포가 가능하다.
- 컨테이너를 사용하는 목적으로는
  - 인프라 사용 효율 향상
  - 빠른 기동 시간
  - 불변 실행 환경
- 가상 서버와 비교하면 컨테이너의 장점으로는
  - 경량
  - 빠른기동
  - 이식성
- 도커의 아키텍처는 클라이언트/서버 모델을 따르며, 서버인 도커 데몬이 클라이언트인 도커 커맨드로부터 요청을 받아 동작한다.
- 컨테이너 이미지를 보존하는 레지스트리는 개발한 컨테이너 이미지를 쿠버네티스에서 실행하기 위한 중간 창고 같은 존재이다.
- 쿠버네티스 스택은 예전부터 주로 도커를 런타임 환경으로 사용했는데, CRI 로 컨테이너 실행환경과 연동하는 식으로 발전하고 있다.
- 컨테이너 내의 실행파일은 리눅스의 표준 규격 LBS에 의해 실행이 보증된다. 그리고 컨테이너 OCI 가 정하는 업계 표준을 지킴으로써 이식성이 확보된다.

-----

참고서적 - 15단계로 배우는 도커와 쿠버네티스