---
title: "Greedy Algorithm : 탐욕 알고리즘"
date: 2020-10-11 12:09:46
category: algorithm
thumbnail: { thumbnailSrc }
draft: false
---

- 탐욕 알고리즘은 전역 최적화를 목표로 하지만, 실제로는 국소 최적화를 한다.
- NP-완전 문제는 빠른 해답이 알려지지 않았다.
- 만약 NP-완전 문제가 주어지면 근사 알고리즘을 쓰는 것이 최선이다.
- 탐욕 알고리즘은 작성하기도 쉽고 빠르기 때문에 좋은 근사 알고리즘이 될 수 있다.

## 탐욕 알고리즘이란?

최적해를 구하는 상황에서 사용하는 방법이다. 여러 경우 중 `주어진 상황에서 가장 좋다고 생각되는 것을 선택`하는 방식으로 진행하기 때문에 가장 좋은 결과를 얻었다는 보장이 없다.

예시) 0을 시작으로 연결된 수를 더해 높은 수를 찾아라.
```js
     [0]
     | |
  [40] [55]
  |  |  | |
[33][1][2][5]
```
0을 시작으로, 연결된 수 중 높은 수 55를 선택 다음 연결될 수 중 높은 수 5를 선택해서 `(55 +5 = 60)` 라는 결과를 얻지만, 연결된 숫자들 중 높은 수는 0, 40, 33 로 `(40 + 33 = 73)` 이다.<br/><br/>
위 예시에서 볼 수 있듯이 최적해를 보장해 주지 않는다.

## 탐욕 알고리즘 예시1 - 동전 지불

문제: 지불해야 하는 값이 362원 일 때, 1원 50원 100원 짜리 동전으로 동전의 수가 가장 적게 지불하시오.

```py
def min_calc(value, coin):
  a=[]
  for i in coin:
    a.append([value-i, i])
  res = a[0]
  # 가장 적은수의 계산결과 값 배열을 찾는다.
  for i in a:
    if res[0] > i[0] and i[0] >= 0:
      res = i
  # 0 보다는 크지만 가장 많이 깎인 금액과, 동전을 배열로 리턴
  return res

coin = [1, 10, 50, 100]
value = [562, 0]
dic = {}

for i in coin:
  dic[i] = 0

while True:
  value = min_calc(value[0], coin)
  # 전달 받은 값 [현재 계산 후 금액, 사용된 동전]
  # 계산되어진 금액이 0보다 작을경우 STOP
  if value[0] < 0:
    break
  else:
    # 사용된 동전, 사용횟수 1 추가
    dic[value[1]] += 1

print(dic)
# {1: 2, 10: 1, 50: 1, 100: 5}
```

높은 금액 코인부터 사용하도록 코드를 수정하면 아래와 같다.<br/>
(코인을 1회씩 쓰면서 loop을 도는 횟수보다, 더 적은 loop 횟수로 답을 찾을 수 있다.)

```py
def max_calc(value, coin):
  res=[]
  for i in coin:
    # 코인금액 만큼 값 나누기
    calc = int(value / i)
    # 한번도 res에 들어가지 않고, 나눈 값이 0 초과일 때
    if len(res) == 0 and calc > 0:
      res = [value - calc*i, i, calc]
      break
  
  # 모든 코인의 값이 나눈값이 0일 경우
  if len(res) == 0:
    # [남은 값 0, 코인 중 가장 낮은 금액코인, 사용 수 1]
    return [0, coin[len(coin)-1], 1]

  # [가장 높은 금액의 코인으로 나눈 값의 나머지, 사용된 코인, 사용된 코인 횟수]
  return res

coin = [100, 50, 10, 1]
# [값, 코인금액, 코인 사용 횟수]
value = [562, 0, 0]
dic = {}

for i in coin:
  dic[i] = 0

while True:
  value = max_calc(value[0], coin)
  # 사용된 코인에 사용된 횟수 더하기
  dic[value[1]] += value[2]
  # 남은 금액이 0 이하일 경우 loop 멈춤
  if value[0] <= 0:
    break

print(dic)
# {100: 5, 50: 1, 10: 1, 1: 2}
```

## 탐욕 알고리즘 예시2
가장 빨리 가는 길을 찾으려고 한다면?<br/>
- 출발하기 전, 가는 거리와 신호등, 교통 상황 등을 전부 계산해서 최적의 길 찾기
- 일단 출발하고 갈림길이 생길 때마다 빠르게 갈 수 있는 길을 찾아서 이동하기

위 2가지중 2번째 방법이 탐욕 알고리즘에 속한다.

## 관련되어 사용될 알고리즘?

무조건 큰 값, 무조건 작은 값, 무조건 짧은 길이, 무조건 긴 길이 등 극단적으로 문제에 접근하는 경우에 많이 쓰이기 때문에 `정렬 알고리즘`을 사용하게 된다.

---

## 출처

https://gomguard.tistory.com/119

https://jeongw00.tistory.com/168

https://developer-mac.tistory.com/53